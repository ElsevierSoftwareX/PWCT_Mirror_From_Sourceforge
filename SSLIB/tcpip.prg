*-------------------------------------------------------------------------*
*
*  http://www.sourceforge.net/projects/doublesvsoop
*
*  DoubleS Project (DoubleS Paradigm,DoubleS Framework & DoubleS Library)
*
*  Copyright(C) 2006-2007, Mahmoud Fayed (msfclipper@hotmail.com)
*
*  TCPIP SERVER - USED FOR VETO SYSTEM LEVEL 3 (VSL3)
*-------------------------------------------------------------------------*

#include "ssxhb.ch"
SET PROCEDURE TO SSLIB.PRG
Function Main
START DOUBLES
*-------------------------------------------------------------------*
* This file generated by DoubleS Framework 1.0                      
* True DoubleS Compiler -> Standard DoubleS Syntax & Statements
* Date : 05/22/07
* Time : 20:37:45
*-------------------------------------------------------------------*
New Server TCPIP Type Slave Server Eigen Value 000
Details:
	DataUnit:
			Atom COM                           
				Shell K
					SubShell P
					SubShell F
						Var islisten                      
						Var osocket                       
						Var osocketclient                 
						Var mysocket                      
						Var sconsarr                      
						Var cconsarr                      
						Var waitconnection                
						Var multisend                     
						Var feedback                      
	CodeUnit:
		Main resistance CIRCUITS\C1\B1\STARTUP                                                                              
			Circuit        C1                            
			MainSwitch     On
				Branch     B1                            
				ParallelTo 0                             
					Resistance STARTUP                       
					Resistance NEW_CONNECTION                
				Branch     B2                            
				ParallelTo 0                             
					Resistance CONNECT                       
					Resistance SENDDATA                      
					Resistance CLOSE                         
					Resistance BIND                          
					Resistance ACCEPT                        
					Resistance multisendon                   
					Resistance multisendoff                  
					Resistance feedbackon                    
					Resistance feedbackoff                   
					Resistance SENDVETO                      
				Branch     B3                            
				ParallelTo 0                             
				Switch     On
					Resistance ENGINE                        
	VetoUnit:
		Receiving Veto NEW_CONNECTION
		Veto CONNECT
				Type General
				Circuit    C1
				Branch     B2
				Resistance CONNECT
		Veto SENDDATA
				Type General
				Circuit    C1
				Branch     B2
				Resistance SENDDATA
		Veto CLOSE
				Type General
				Circuit    C1
				Branch     B2
				Resistance CLOSE
		Veto NEW_CONNECTION
				Type General
				Circuit    C1
				Branch     B1
				Resistance NEW_CONNECTION
		Veto BIND
				Type General
				Circuit    C1
				Branch     B2
				Resistance BIND
		Veto multisendon
				Type General
				Circuit    C1
				Branch     B2
				Resistance multisendon
		Veto multisendoff
				Type General
				Circuit    C1
				Branch     B2
				Resistance multisendoff
		Veto feedbackon
				Type General
				Circuit    C1
				Branch     B2
				Resistance feedbackon
		Veto feedbackoff
				Type General
				Circuit    C1
				Branch     B2
				Resistance feedbackoff
		Veto SENDVETO
				Type General
				Circuit    C1
				Branch     B2
				Resistance SENDVETO
		Channel MY_INPUT_CHANNEL
				Type     Input Channel
				Atom     COM
				Shell    K
				SubShell P
End Of Server 

	Resistance WIN32EVENTS() Address Code Unit : WIN32EVENTS

  ADD RESISTANCE WIN32EVENTS 


Resistance RUZSLC1() address Code Unit : Circuits\C1\B1\STARTUP

Resistance RUZSLC2() address Code Unit : Circuits\C1\B2\CONNECT

Resistance RUZSLC3() address Code Unit : Circuits\C1\B2\SENDDATA

Resistance RUZSLC4() address Code Unit : Circuits\C1\B2\CLOSE

Resistance RUZSLC5() address Code Unit : Circuits\C1\B3\ENGINE

Resistance RUZSLC6() address Code Unit : Circuits\C1\B1\NEW_CONNECTION

Resistance RUZSLC7() address Code Unit : Circuits\C1\B2\BIND

Resistance RUZSLC8() address Code Unit : Circuits\C1\B2\ACCEPT

Resistance RUZSLC9() address Code Unit : Circuits\C1\B2\multisendon

Resistance RUZSLC10() address Code Unit : Circuits\C1\B2\multisendoff

Resistance RUZSLC11() address Code Unit : Circuits\C1\B2\feedbackon

Resistance RUZSLC12() address Code Unit : Circuits\C1\B2\feedbackoff

Resistance RUZSLC13() address Code Unit : Circuits\C1\B2\SENDVETO

startserver()

  FUNCTION STARTSERVER()
   	Server FireON
  RETURN

  RESISTANCE WIN32EVENTS() CODE
  RETURN

* Resistance Code Unit : Circuits\C1\B1\STARTUP
Resistance RUZSLC1() code
LOCAL MYPATH
 select address com:k:f
 load active subshell from memory
 sconsarr = {}
 cconsarr = {}
 islisten = 0
 waitconnection = .f.
 multisend = .f. && when send = send to all clients (not applied now , value = .f.)
 feedback = .f.   && send what you recive (now applied now, value = .f.)
HB_INETInit()
osocketclient = ""

MYPATH = MEMOREAD("VETOPATH.TXT")
MYPATH = ALLTRIM(MYPATH)
? " Veto system level 2 " + chr(13) + ;
                   " From File vetopath.txt " + chr(13) + ;
                   " path : " + mypath,"Welcome to TCPIP Server"
Set veto system level 2
Set veto system path (MYPATH)
Select INPUT CHANNEL MY_INPUT_CHANNEL
****************************************
SET COLOR TO W/B
CLEAR
? "Welcome To"
? "TCP/IP Server "
End Of Resistance

* Resistance Code Unit : Circuits\C1\B2\CONNECT
Resistance RUZSLC2() code
 LOCAL MYADDRESS,MYPORT
 open channel my_input_channel
 goto first electron
 myaddress := GET_ACTIVE_ELECTRON_VALUE
 goto next electron 
 myport := GET_ACTIVE_ELECTRON_VALUE
 CLEAR CHANNEL
 CLOSE CHANNEL
osocket = HB_INETConnect( myaddress,VAL(myport) )
? " Connect "
? " Address : " + myaddress
? " Port         : " + myport
HB_INETTIMEOUT( OSOCKET, 100 )
aadd(cconsarr,osocket)
End Of Resistance

* Resistance Code Unit : Circuits\C1\B2\SENDDATA
Resistance RUZSLC3() code
LOCAL mydata
 open channel my_input_channel
 goto first electron
 mydata := GET_ACTIVE_ELECTRON_VALUE
 CLEAR CHANNEL
 CLOSE CHANNEL
if islisten = 2
if multisend = .t.
if .not. len(sconsarr) = 0
for x = 1 to len(sconsarr)
osocketclient = sconsarr[x]
HB_INETSend( osocketclient, mydata )
? " Send Data :" + mydata
? " Error Code : "
?? HB_INETERRORCODE(OSOCKETCLIENT)
next
endif
else
HB_INETSend( osocketclient, mydata )
? " Send Data :" + mydata

? " Error Code : "
?? HB_INETERRORCODE(OSOCKETCLIENT)
endif
Endif

if islisten = 0
HB_INETSend( osocket, mydata )
? " Send Data :" + mydata
? " Error Code : "
?? HB_INETERRORCODE(OSOCKET)
endif
End Of Resistance

* Resistance Code Unit : Circuits\C1\B2\CLOSE
Resistance RUZSLC4() code

HB_INETClose( oSOCKET )
End Of Resistance

* Resistance Code Unit : Circuits\C1\B3\ENGINE
Resistance RUZSLC5() code
local mystr,mystr2,x,y
hb_gcall()
if waitconnection = .t.
VFUNCNAME = SS_GRFUNC("CIRCUITS\C1\B2\ACCEPT")
VFUNCNAME = ALLTRIM(VFUNCNAME)
VFUNCNAME = LEFT(VFUNCNAME,LEN(VFUNCNAME)-2)
hb_threadstart(VFUNCNAME,@mysocket,@osocketclient,@islisten,@sconsarr,@waitconnection)
 waitconnection = .f.
endif
* server side
if islisten = 2
if .not. len(sconsarr) = 0
for x = 1 to len(sconsarr)
osocketclient = sconsarr[x]
      MYSTR := space(50)
      HB_INETRecv( osocketclient, @MYSTR  )
       if .not. empty(alltrim(mystr)) 
        if .NOT. upper(left(mystr,13)) == "[(*VETOSYS*)]"
          START REPLY 
         CON_SENDDATA (MYSTR)
          CON_SENDVETO DATA_ARRIVAL
           END REPLY
          ELSE
          mystr2 = substr(mystr,14,len(mystr)-13)
          START REPLY 
          CON_SENDVETO (MYSTR2)
           END REPLY
         ENDIF
          ? " Data Arrival :" + mystr
          ? " Error Code : "
          ?? HB_INETERRORCODE(OSOCKETCLIENT)
        if feedback = .t.
            OLDSOCKET = OSOCKETCLIENT
            if .not. len(sconsarr) = 0
              for y = 1 to len(sconsarr)
                 osocketclient = sconsarr[y]
                 HB_INETSend( osocketclient, mystr )
                ? " Send Data :" + mystr
                ? " Error Code : "
                ?? HB_INETERRORCODE(OSOCKETCLIENT)
             next
           endif
           OSOCKETCLIENT = OLDSOCKET
        endif
        endif

next
endif
endif

*client side
if islisten = 0
if .not. len(cconsarr) = 0
for x = 1 to len(cconsarr)
osocket = cconsarr[x]
      MYSTR := space(128)
            HB_INETRecv( osocket, @MYSTR  )
 if .not. empty(alltrim(mystr)) 
  if .NOT. upper(left(mystr,13)) == "[(*VETOSYS*)]"
          START REPLY 
         CON_SENDDATA (MYSTR)
          CON_SENDVETO DATA_ARRIVAL
           END REPLY
          ELSE

          mystr2 = substr(mystr,14,len(mystr)-13)
          START REPLY 
          CON_SENDVETO (MYSTR2)
           END REPLY
ENDIF
? " Data Arrival :" + mystr
? " Error Code : "
?? HB_INETERRORCODE(OSOCKET)
 endif
next
endif
endif
End Of Resistance

* Resistance Code Unit : Circuits\C1\B1\NEW_CONNECTION
Resistance RUZSLC6() code
if REQUEST_TYPE_CONNECTION = .T.
?  "THERE ARE CONNECTION"
 accept connection
endif

End Of Resistance

* Resistance Code Unit : Circuits\C1\B2\BIND
Resistance RUZSLC7() code
LOCAL MYADDRESS,MYPORT
 open channel my_input_channel
 goto first electron
 myaddress := GET_ACTIVE_ELECTRON_VALUE
 goto next electron 
 myport := GET_ACTIVE_ELECTRON_VALUE
 CLEAR CHANNEL
 CLOSE CHANNEL
*MYSOCKET = HB_INETServer(VAL(myport),myaddress)
MYSOCKET = HB_INETServer(VAL(myport))
? " BIND "
? " Address : " + myaddress
? " Port         : " + myport
waitconnection = .t.
islisten = 1
End Of Resistance

* Resistance Code Unit : Circuits\C1\B2\ACCEPT
Resistance RUZSLC8() code
parameters p_mysocket,p_osocketclient,p_islisten,p_sconsarr,p_waitconnection
? "before accept"
p_osocketclient := HB_INETAccept( p_MYSOCKET )
? "after accept"
HB_INETTIMEOUT( p_OSOCKETCLIENT, 100 )
? "Send welcome"
p_islisten = 2
aadd(p_sconsarr,p_osocketclient)
p_waitconnection = .t.
End Of Resistance

* Resistance Code Unit : Circuits\C1\B2\multisendon
Resistance RUZSLC9() code
 multisend = .t.
End Of Resistance

* Resistance Code Unit : Circuits\C1\B2\multisendoff
Resistance RUZSLC10() code
 multisend = .f.

End Of Resistance

* Resistance Code Unit : Circuits\C1\B2\feedbackon
Resistance RUZSLC11() code
 feedback = .t.

End Of Resistance

* Resistance Code Unit : Circuits\C1\B2\feedbackoff
Resistance RUZSLC12() code
 feedback = .f.


End Of Resistance

* Resistance Code Unit : Circuits\C1\B2\SENDVETO
Resistance RUZSLC13() code
LOCAL mydata
 open channel my_input_channel
 goto first electron
 mydata := GET_ACTIVE_ELECTRON_VALUE
 CLEAR CHANNEL
 CLOSE CHANNEL
 MYDATA =  "[(*VETOSYS*)]" + MYDATA

if islisten = 2
if multisend = .t.
if .not. len(sconsarr) = 0
for x = 1 to len(sconsarr)
osocketclient = sconsarr[x]
HB_INETSend( osocketclient, mydata )
? " Send Data :" + mydata
? " Error Code : "
?? HB_INETERRORCODE(OSOCKETCLIENT)
next
endif
else
HB_INETSend( osocketclient, mydata )
? " Send Data :" + mydata
? " Error Code : "
?? HB_INETERRORCODE(OSOCKETCLIENT)
endif
Endif
if islisten = 0
HB_INETSend( osocket, mydata )
? " Send Data :" + mydata
? " Error Code : "
?? HB_INETERRORCODE(OSOCKET)
endif
End Of Resistance

*-------------------------------------------------------------------*
