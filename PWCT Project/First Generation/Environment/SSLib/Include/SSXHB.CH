*-----------------------------------------------------------*
* SERVER INFORMATION
*-----------------------------------------------------------*
#command START DOUBLES => SS_ON()
#command NEW SERVER <(servername)> TYPE <(servertype)> SERVER EIGEN VALUE <(EIGENVALUE)> => ;
         SS_NEWSERVER(<(servername)>,<(servertype)>,<(EIGENVALUE)>)
#xtranslate Details : => 
#xtranslate Servers :    => 
#xtranslate Networks :    => 
#command DATAUNIT : => SS_FLAG3 = 1 ;;
                        SS_FLAG  = 1 ;;
                        SS_FLAG2 = 1
#command ATOM <(X)> => SS_NEWATOM( <(X)> )
#command SHELL <(X)> => SS_NEWSHELL( <(X)> )
#command SUBSHELL <(X)> => SS_NEWSUBSHELL( <(X)> )
#command SUBSHELL <X> : <X2> => SS_NEWRITEM(<(X)> +':'+ <(X2)> , 4)
#command VAR <(X)> [VALUE <(X2)>] => SS_NEWVAR( <(X)> , 1 , <X2> )
#command Variable <(X)> [VALUE <(X2)>] => SS_NEWVAR( <(X)> , 1 , <X2> )
#command DATABLOCK [VALUE <(X2)>] => SS_NEWVAR( "DATA_BLOCK" , 2 , <X2> )
#command DATABLOCK <(X)> [VALUE <(X2)>] => SS_NEWVAR( <(X)> , 2 , <X2> )
#command REFERENCE <(X)> [VALUE <(X2)>] => SS_NEWVAR( <(X)> , 3 , <X2> )
#command VESSEL <(X)> =>   SS_FLAG = 2  ;;
                           SS_NEWVESSEL( <(X)> )
#command REACTION <(X)> => SS_FLAG = 3 ;;
                           SS_FLAG2 = 2 ;;
                           SS_NEWREACTION( <(X)> )
#command CODEUNIT : => SS_FLAG  = 4 ;;
                        SS_FLAG2 = 3 ;;
                        SS_FLAG3 = 2
#command CIRCUIT <(X)> => SS_NEWCIRCUIT( <(X)> )
#xtranslate MAIN RESISTANCE <X> => SS_SMSR( <(X)> )
#command MAIN CIRCUIT <(X)> =>
#command MAINRESISTANCE <(X)> => SS_MRESIS( <(X)> )
#command MAINSWITCH <(X)> => SS_MSWITCH( <(X)> )
#command SWITCH <(X)>  =>  SS_BSWITCH( <(X)> )
#command PARALLELTO <(X)> => SS_BPATO( <(X)> )
#command PARALLELTO 0 => SS_BPATO( 0 )
#command BRANCH <(X)> => SS_NEWBRANCH( <(X)> )
#command RESISTANCE <(X)> => SS_NRESIS( <(X)> )
#command VETOUNIT : => SS_FLAG3 = 3
#xtranslate RECEIVING VETO <X1> => SS_RECVETO( <(X1)> )
#command SENDING VETO <X1> => SS_SENVETO( <(X1)> )
#command VETO  <(X)> => SS_NEWVETO( <(X)> )
#command TYPE <X> : <X2> <X3> => SS_VTYPE( <(X)> )
#command TYPE GENERAL => SS_VTYPE( "GENERAL" )
#command TYPE <X> CHANNEL => SS_CHTYPE( <(X)> )
#command TYPE NEW CLIENT (NEW OBJECT ) => SS_CONTYPE(1)
#command TYPE MASTER TO SLAVE CONNECTION => SS_CONTYPE(2)
#command TYPE SLAVE TO MASTER CONNECTION => SS_CONTYPE(3)
#command TYPE NETWORK TO NETWORK => SS_CONTYPE(4)
#command CHANNEL <(X)> => SS_NEWCHANNEL( <(X)> )
#command CONNECTION <(X)> =>    ;
                                SS_FLAG3 = 4 ;;
                                SS_NEWCONNECTION( <(X)> )
#command INPUTCHANNEL  <(X)> => SS_CONSET( <(X)> , 1)
#command OUTPUTCHANNEL <(X)> => SS_CONSET( <(X)> , 2)
#xtranslate SENDINGVETO   [<(X)>] => SS_CONSET( [<(X)>] , 3)
#xtranslate RECEIVINGVETO [<(X)>] => SS_CONSET( [<(X)>] , 4)
#command ELECTRON <(X)> => SS_CONSET( <(X)> , 8)
#command SERVER <(X)> => SS_CONSERVER( <(X)> )
#command END OF SERVER =>
#xcommand RESISTANCE <X> Address Code Unit : <x2>  => ;
                        SS_NEWR( <(X)> , <(x2)> )
#xcommand RESISTANCE <X> Code [<static: STATIC>] => ;
                        <static> function <X>
#xtranslate CALL RESISTANCE <X> => ss_callr( <(X)> )
#command END OF RESISTANCE => return
*---------------------------------------------------------------*
* DOUBLES STATEMENTS - FOR DATA UNIT
*---------------------------------------------------------------*
#command SELECT ATOM <X> => SS_SELECT(1, <(X)> )
#command SELECT SHELL <X> => SS_SELECT(2, <(X)> )
#command SELECT SUBSHELL <X> => SS_SELECT(3, <(X)> )
#command SELECT ADDRESS <X>:<X2>:<X3> => ;
                                        SS_SELECT(1, <(X)>) ;;
                                        SS_SELECT(2, <(X2)>) ;;
                                        SS_SELECT(3, <(X3)>)
#command LOAD ACTIVE SUBSHELL FROM MEMORY => SS_LOADSUBSHELL()
#command UPLOAD ACTIVE SUBSHELL TO MEMORY => SS_UPLOADSUBSHELL()
#define  GET_ACTIVE_ATOM        SS_GAAN()
#define  GET_ACTIVE_SHELL       SS_GASN()
#define  GET_ACTIVE_SUBSHELL    SS_GASSN()
#define  GET_ATOMS_COUNT        SS_AC()
#define  GET_SHELLS_COUNT       SS_SC()
#define  GET_SUBSHELLS_COUNT    SS_SSC()
#define  GET_ELECTRONS_COUNT    SS_EC()
#define  GET_VESSELS_COUNT      SS_VC()
#define  GET_REACTIONS_COUNT    SS_RC()
#define  GET_CIRCUITS_COUNT     SS_CC()
#define  GET_BRANCHES_COUNT     SS_BC()
#define  GET_RESISTANCES_COUNT  SS_RESC()
#define  GET_VETOS_COUNT        SS_VETOSC()
#define  GET_CHANNELS_COUNT     SS_CHC()
#define  GET_CONNECTIONS_COUNT  SS_CONC()
#define  GET_ACTIVE_ELECTRON_ID        SS_EID()
#define  GET_ACTIVE_ELECTRON_NUM       SS_ENUM()
#define  GET_ACTIVE_ELECTRON_NAME      SS_ENAME()
#define  GET_ACTIVE_ELECTRON_VALUE     SS_EVALUE()
#command SET ACTIVE ELECTRON VALUE TO <X1> => SS_SEVALUE(<(X1)>)
#define  GET_ACTIVE_ELECTRONS_COUNT    SS_AEC()
#command GOTO FIRST ELECTRON   => SS_GTFE()
#command GOTO LAST ELECTRON    => SS_GTLE()
#command GOTO NEXT ELECTRON    => SS_GTNE()
#command GOTO PREV ELECTRON    => SS_GTPE()
#command DELETE ACTIVE ELECTRON  => SS_DAE()
#command DELETE ALL ACTIVE ELECTRONS  => SS_DAAE()
#command COPY ELECTRONS TO <X21>:<X22>:<X23> => SS_COPYTA( <(X21)> , <(X22)> , <(X23)> )
#command COPY ADDRESS <X>:<X2>:<X3> ELECTRONS TO <X21>:<X22>:<X23> => SS_ACOPYTA( <(X)> , <(X2)> , <(X3)> , <(X21)> , <(X22)> , <(X23)> )
#command MOVE ELECTRONS TO <X21>:<X22>:<X23> => SS_MOVETA( <(X21)> , <(X22)> , <(X23)> )
#command MOVE ADDRESS <X>:<X2>:<X3> ELECTRONS TO <X21>:<X22>:<X23> => SS_AMOVETA( <(X)> , <(X2)> , <(X3)> , <(X21)> , <(X22)> , <(X23)> )
#command ADD MARK <X> TO ADDRESS <X2>:<X3>:<X4> => SS_ADDMARK( <(X)> , <(X2)> , <(X3)> , <(X4)> )
#command CREATE ELECTRONS LIST <X> => <X> := {}
#command OPEN ELECTRONS LIST <X>   => SS_OEL( <(X)> )
#command CLOSE ELECTRONS LIST      => SS_CEL()
#command ADD ELECTRON TO LIST      => SS_AETL()
#command DELETE ELECTRON FROM LIST  => SS_DEFL()
#command SET DOMAIN <electronlist>  => SS_SETDOMAIN( <electronlist> )
#command CLOSE DOMAIN   => SS_CLOSEDOMAIN()
#command INVOKE REFERENCE => CALL RESISTANCE  (GET_ACTIVE_ELECTRON_VALUE)

* DATA UNIT : Virtual DBMS (Chemical System)
#command NEW VIRTUAL DATA FILE <X1> DETAILS <X2>:<X3>:<X4> DATA <X5>:<X6>:<X7> => SS_NVDF( <(X1)> , <(X2)> , <(X3)> , <(X4)> , <(X5)> , <(X6)> , <(X7)> )
#command OPEN VIRTUAL DATA FILE <X1> => SS_OVDF( <(X1)> )
#command CLOSE VIRTUAL DATA FILE => SS_CVDF()
#command SELECT AREA <X1> =>  SS_SAREA( <(X1)> )
#command LOAD RECORD  => SS_LR()
#command UPLOAD RECORD  => SS_UR()
#command ADD NEW RECORD => SS_ADDNR()
#command DELETE THIS RECORD => SS_DELTR()
#command GOTO FIRST RECORD => SS_GOTOFR()
#command GOTO LAST RECORD => SS_GOTOLR()
#command GOTO NEXT RECORD => SS_GOTONR()
#command GOTO PREV RECORD => SS_GOTOPR()
#define  GET_RECORD_NUMBER      SS_GRN()
#define  GET_RECORDS_COUNT      SS_GRC()
#command SEARCH ABOUT <CONDITION> => SS_SEARABOUT( <(CONDITION)> )
#command SEARCH OTHER => SS_SEAROTHER()
#define  THERE_ARE_RESULT                      SS_TAR()
#define  GET_ACTIVE_AREA_NUM                   SS_GAANUM()
#define  GET_ACTIVE_VIRTUAL_DATA_FILE_NAME     SS_GAVDFNAME()
#xtranslate ADD NEW ELECTRON <X1> TYPE <X2>   => SS_CNELE(<(X1)>,<X2>)
#xtranslate STACK_PUSH <X1> => SS_PUSH(<(X1)>)
#xtranslate STACK_POP => SS_POP()
#xtranslate QUEUE_PUSH <X1> => SS_PUSH(<(X1)>)
#xtranslate QUEUE_FRONT => SS_FRONT()
* vessels
#command OPEN VESSEL <X1> =>  SS_OVESSEL( <(X1)> )
#command CLOSE VESSEL =>  SS_CVESSEL()
#command GOTO FIRST ATOM => SS_GTFAA()
#command GOTO LAST ATOM => SS_GTLAA()
#command GOTO NEXT ATOM => SS_GTNAA()
#command GOTO PREV ATOM => SS_GTPAA()
#define  GET_ACTIVE_ATOM_NAME   SS_ANAME()
#define  GET_ACTIVE_ATOMS_COUNT   SS_AACOUNT()
#command SELECT ACTIVE ATOM => SS_SAA()
* REACTIONS
#command ACTIVE REACTION <X1> => SS_AR(<(X1)>)
#command UNACTIVE REACTION  => SS_UNAR()
#define  GET_REACTION_VESSELS_COUNT   SS_GRVC()
#define  GET_REACTION_ATOMS_COUNT   SS_GRAC()
#define  GET_REACTION_SHELLS_COUNT   SS_GRSC()
#define  GET_REACTION_SUBSHELLS_COUNT   SS_GRSSC()
#define  GET_REACTION_VESSEL_NAME   SS_GRVN()
#define  GET_REACTION_ATOM_NAME   SS_GRAN()
#define  GET_REACTION_SHELL_NAME   SS_GRSN()
#define  GET_REACTION_SUBSHELL_NAME   SS_GRSSN()
#command REACTION GOTO FIRST VESSEL => SS_RGTFV()
#command REACTION GOTO LAST VESSEL => SS_RGTLV()
#command REACTION GOTO NEXT VESSEL => SS_RGTNV()
#command REACTION GOTO PREV VESSEL => SS_RGTPV()
#command REACTION GOTO FIRST ATOM => SS_RGTFA()
#command REACTION GOTO LAST ATOM => SS_RGTLA()
#command REACTION GOTO NEXT ATOM => SS_RGTNA()
#command REACTION GOTO PREV ATOM => SS_RGTPA()
#command REACTION GOTO FIRST SHELL => SS_RGTFS()
#command REACTION GOTO LAST SHELL => SS_RGTLS()
#command REACTION GOTO NEXT SHELL => SS_RGTNS()
#command REACTION GOTO PREV SHELL => SS_RGTPS()
#command REACTION GOTO FIRST SUBSHELL => SS_RGTFSS()
#command REACTION GOTO LAST SUBSHELL => SS_RGTLSS()
#command REACTION GOTO NEXT SUBSHELL => SS_RGTNSS()
#command REACTION GOTO PREV SUBSHELL => SS_RGTPSS()
* CODE UNIT : Event Driven System (Electrical Circuits)
#command SERVER FIREON => SS_FIREON()
#command SERVER SHUTDOWN => SS_SHUTDOWN()
#command WITH CIRCUIT <X1>  => SS_WCIRCUIT( <(X1)> )
#command SET MAIN RESISTANCE = <X1> => SS_SMRES(<(X1)>)
#command SET MAIN SWITCH ON => SS_SMSON()
#command SET MAIN SWITCH OFF => SS_SMSOFF()
#command RESTART => SS_RESTART()
#command SET DIRECTION DOWN =>  SS_SDDOWN()
#command SET DIRECTION UP =>  SS_SDUP()
#command SET DIRECTION DOWN UP  => SS_SDDU()
#command SET DIRECTION UP DOWN  => SS_SDUD()
#command END WITH CIRCUIT => SS_EWCIRCUIT()
#command WITH BRANCH <X1> => SS_WBRANCH(<(X1)>)
#command SET SWITCH ON => SS_SSON()
#command SET SWITCH OFF => SS_SSOFF()
#command SET PARALLEL = <X1> => SS_SPARALLEL(<(X1)>)
#command FIREON ME=> SS_MEFIREON()
#define  GET_BRANCH_SWITCH_STATUS  SS_GBSS()
#define  GET_PARALLEL              SS_GPARALLEL()
#command END WITH BRANCH =>        SS_EWBRANCH()
#define  GET_ACTIVE_CIRCUIT        SS_GACIRCUIT()
#define  GET_ACTIVE_BRANCH         SS_GABRANCH()
#define  GET_ACTIVE_RESISTANCE     SS_GARES()
#command ADD RESISTANCE <X1>   => SS_ADDRES(<(X1)>)
#command DO SYSTEM EVENTS      => SS_DOEVENTS()
#command SLEEPTIME <X1>        => SS_SLEEPT(<(X1)>)
* VETO UNIT : Client - Server (Human Interaction)
#command SELECT INTERACTION CONNECTION <X1> => SS_SIC(<(X1)>)
#command SELECT CLIENT CONNECTION <X1>:<X2>:<X3>:<X4> => SS_SCC(<(X1)>,<(X2)>,<(X3)>,<(X4)>)
#command CON_CONNECT    => SS_CCONNECT()
#command CON_BEGIN_TRANSACTION => SS_CBT()
#command CON_SENDVETO <X1> => SS_CSV(<(X1)>)
#command CON_SENDDATA <X1> => SS_CSD(<(X1)>)
#command CON_END_TRANSACTION => SS_CET()
#command CON_SELECT_INPUT_CHANNEL =>  SS_CSIC()
#command CON_SELECT_OUTPUT_CHANNEL => SS_CSOC()
#command CON_CHANNEL_PUTDATA FORM <X1>:<X2>:<X3> => SS_CCPF(<(X1)>,<(X2)>,<(X3)>)
#command CONCHANNEL_GETDATA FOR  <X1>:<X2>:<X3> =>  SS_CCGF(<(X1)>,<(X2)>,<(X3)>)
#command CON_DISCONNECT           =>   SS_CDISCONNECT()
#command SELECT INPUT CHANNEL <X1> => SS_SICH(<(X1)>)
#command OPEN CHANNEL <X1>         => SS_OPCH(<(X1)>)
#command CLOSE CHANNEL         => SS_CLOSECH()
#command CLEAR CHANNEL        => SS_CLEARCH()
#define  GET_SENDER_SERVER_NAME    SS_GSSNAME()
#define  GET_SENDER_SERVER_TYPE    SS_GSSTYPE()
#define  GET_SENDER_SERVER_EIGENVALUE SS_GSSEV()
#define  GET_VETO_DECISION    SS_GVDEC()
#command ACCEPT CONNECTION   => SS_ACCCON()
#command REFUSE CONNECTION   => SS_REFCON()
#define  CONNECTION_ACCEPTED  SS_CONACC()
#define  REQUEST_TYPE_CONNECTION  SS_RTCON()
#define  REQUEST_TYPE_SENDDATA    SS_RTSD()
#define  REQUEST_TYPE_SENDVETO    SS_RTSV()
#define  REQUEST_VETO_NAME    SS_RVNAME()
#command SET VETO SYSTEM PATH <X1> => SS_SVSP(<(X1)>)
#command SET VETO SYSTEM LEVEL <X1> => SS_SVSL(<(X1)>)
#command CHECK_VETO_SERVICES => SS_CVSER()
#XTRANSLATE START REPLY => SS_REPSTART()
#XTRANSLATE END REPLY => SS_REPEND()
* veto system level 3
#command declare server <X1> address <X2> port <X3> => ss_dsap(<(X1)>,<(X2)>,<(X3)>)
#command START BIND => SS_STARTBIND()
* OOP SIMULATION :
#xtranslate CREATE CLASS <X1> [FROM <X2>] DATA <X3> METHODS <X4> => SS_NCLASS(<(X1)>,<(X2)>,<(X3)>,<(X4)>)        && CREATE NEW CLASS
#xtranslate CREATE OBJECT [<X1>] FROM <X2> => SS_NOBJECT(<(X1)>,<(X2)>)       && CREATE NEW OBJECT
#xtranslate WITH OBJECT <X1> => SS_WITHOBJ(<(X1)>)       && WITH OBJECT
#xtranslate  END WITH OBJECT => SS_EWITHOBJECT()   && END WITH OBJECT
#command DELETE CLASS <X1> => SS_DELCLASS(<(X1)>)      &&  DELETE CLASS
#command DELETE OBJECT <X1> => SS_DELOBJECT(<(X1)>)     &&  DELETE OBJECT
#xtranslate OOP <X1> => SS_OOP2(<(X1)>) 
#xtranslate OOP <X1> = <X2> => SS_OOP1(<(X1)>,<X2>)
#define  CALLED_AS_METHOD  SS_CASMETHOD()
* DOUBLES SYSTEM :
#xcommand SET SYSFLAG ON => SS_SFON()
#xcommand SET SYSFLAG OFF => SS_SFOFF()
***************************************
#DEFINE GET_SERVER_NAME SS_SERVERS[SS_AS][1]
#DEFINE GET_SERVER_TYPE SS_SERVERS[SS_AS][2]
#DEFINE GET_SERVER_EIGENVALUE SS_SERVERS[SS_AS][3]


